#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# Customize to your needs...

plugins=(kubectl)


# Random {{{

#HISTORY
setopt histignorealldups
# Keep 20,000 lines of history within the shell and save it to ~/.zsh_history:
HISTSIZE=20000
SAVEHIST=20000
HISTFILE=~/.zsh_history

# disables relic off the past <C-s> <C-q>
stty -ixon

bindkey '^R' history-incremental-pattern-search-backward
bindkey '^S' history-incremental-pattern-search-forward
bindkey "^P" vi-up-line-or-history
bindkey "^N" vi-down-line-or-history

# needed to defin menuselect
zstyle ':completion:*' menu select
zmodload zsh/complist
# better autocomplete behaviour
bindkey -M menuselect '^M' .accept-line

# Use modern completion system
autoload -Uz compinit
#compinit # maybe uncomment TODO

# (aagg) Mon  5 Nov 17:25:28 GMT 2018
bindkey -v
# slight tweaks
bindkey '^P' up-history
bindkey '^N' down-history
bindkey '^?' backward-delete-char
bindkey '^h' backward-delete-char
bindkey '^r' history-incremental-search-backward
# makes so completion selection doesn't appenda space
bindkey "^O" accept-line 


export KEYTIMEOUT=1
export EDITOR=vim


# }}}
# Source`s {{{

# fzf keybindings
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

source ~/.config/secret/alias.zsh

# Secret
source ~/.config/secret/export_secrets.zsh

# }}}
# Alias {{{ 

alias mvim="/usr/local/Cellar/macvim/8.2-169_2/bin/mvim"
alias macvim="/usr/local/Cellar/macvim/8.2-169_2/bin/mvim"
alias vim="/usr/local/bin/vim"

# fixed node
export PATH="/usr/local/opt/node@10/bin:$PATH"

#add GOPATH
export GOPATH="$HOME/Projects/go"
# add go to PATH
export PATH="$PATH:$GOPATH/bin"
# add ruby to PATH
export PATH="/usr/local/opt/ruby/bin:$PATH"
export PATH="/usr/local/lib/ruby/gems/2.7.0/bin:$PATH"
export PATH="/usr/local/opt/go@1.14/bin:$PATH"
export PATH="$PATH:/usr/local/opt"
export PATH="/usr/local/Cellar:$PATH"
#eval "$(rbenv init -)"

# export paths
export P=~/Projects
export R=~/Projects/go/src/github.palantir.build/rubix
export D=~/Projects/go/src/github.palantir.build/deployability

# bat
alias bat='bat --theme=GitHub'

# ./godelw alias
alias gow='./godelw'

# git
alias gits='git s'
alias gita='git a'
alias gitd='git d'
alias gitc='git c'
alias gitp='git p'

# ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias sl='ls -CF'

alias cl='clear; ls'

# cd
alias cd..='cd ..; ls'
alias cdd='cd ..; ls'

# shortcuts
alias cdroot='cd $(git rev-parse --show-toplevel)'
alias cdp='cd $P; ls'
alias cdr='cd $R; ls'
alias cdg='cd $GOPATH/src; ls'
alias cd-='popd'

alias grp="grep --color=always -i"

# goes to online repo for 
alias remoterepo="gwc remote"

# }}}
# {{{ My Funcs

qload() {
    uqc load $1 | tee /dev/tty | pbcopy
}
qsave() {
    uqc save $1
}

cistatus() {
    hub ci-status -v
    hub ci-status ${SHA}
    RET=$?
    # Exit code of 2 means pending
    while [ ${RET} -eq 2 ]; do
      sleep 20
      hub ci-status ${SHA}
      RET=$?
    done
    hub ci-status -v
}

bastion_ready() {
    while ! host $1 
    do 
        sleep 10
    done
    host $1 
}


alert() {
    osascript -e 'display notification "alert"'
}




# }}}
# {{{ kubectl


kubectl() {
    local context="$(/usr/local/bin/kubectl config current-context)"
    context="${context:0:${#context}/2}"

    local color='\033[0;31m' 
    case $context in 
        *"staging"*)
            color='\033[0;32m'
            ;;
        *"agrabauskas"*)
            color='\033[0;34m'
            ;;
    esac
    echo -e "${color}$context\033[0m"
    /usr/local/bin/kubectl $@
}
alias k=kubectl

kubenodes() {
        kubectl get nodes --selector com.palantir.rubix/infrastructure-node= \
        --label-columns kubernetes.io/hostname,nodetype,failure-domain.beta.kubernetes.io/zone,com.palantir.rubix/instance-id |
        # Emit columns in order HOSTNAME, NODETYPE, ZONE, INSTANCE-ID, NAME, AGE, STATUS
        awk '{print $6, $7, $8, $9, $1, $4, $2}' | column -t | (
        read -r
        # Print header line and sort the rest
        printf "%s\n" "$REPLY"
        sort -bk 2
     )
}

kubectlprod() {
    local context="$(/usr/local/bin/kubectl config current-context)"
    case $context in 
        *"production"*)
            kubectl $@
            ;;
        *"staging"*)
            >&2 echo -e "\033[0;31mError: You are peered to a staging cluster: ${context:0:${#context}/2}"
            return 1
            ;;
    esac
}
alias kubectlp="kubectlprod"
alias kprod="kubectlprod"
alias kp="kubectlprod"

kubectlstaging() {
    local context="$(/usr/local/bin/kubectl config current-context)"
    case $context in 
        *"production"*)
            >&2 echo -e "\033[0;31mError: You are peered to a production cluster: ${context:0:${#context}/2}"
            return 1
            ;;
        *"staging"*)
            kubectl $@
            ;;
    esac
}
alias kubectls="kubectlstaging"
alias kstaging="kubectlstaging"
alias ks="kubectlstaging"

# }}}
# {{{ Completion

autoload -U +X bashcompinit && bashcompinit

source /usr/local/etc/bash_completion.d/az

# }}}
# {{{ Palantir
#

alias render="zsh \$(git rev-parse --show-toplevel)/rubixw render | slslog"
alias project-version="zsh \$(git rev-parse --show-toplevel)/godelw project-version | tee /dev/tty | pbcopy"
alias format="zsh \$(git rev-parse --show-toplevel)/godelw format"


commit_env() {
    COMMIT="$(git log -1 --pretty=%B). $(basename `git rev-parse --show-toplevel`), $(gow project-version)"; echo $COMMIT
}

retrying_render() {
    ./rubixw render || (sleep 20; retrying_render)
}

# }}}
# {{{ Test

# Called every time before the prompt is drawn
precmd() { 
    if [[ -v tabname ]]; then 
        echo -ne "\e]1;${tabname}\a"
    else 
        # Tab name == current folder name
        echo -ne "\e]1;${PWD##*/}\a"
    fi
}


autoload colors; colors
for color (${(k)fg})
  eval "$color() {print -n \$fg[$color]; cat; print -n \$reset_color}"


# }}}
#
# vim: set foldmethod=marker: set foldlevel=1
